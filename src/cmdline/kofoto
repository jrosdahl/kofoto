#! /usr/bin/env python

import os
import sys
import getopt

######################################################################

# Find libraries if installed in ../lib (like in the source tree).
sys.path.insert(0, os.path.join(os.path.dirname(sys.argv[0]), "..", "lib"))

try:
    from kofoto.common import *
    from kofoto.shelf import *
    from kofoto.imagecache import *
except ImportError:
    sys.stderr.write("Could not find the kofoto libraries. " +
                     "Please install kofoto properly.\n")
    sys.exit(1)

######################################################################
### Constants.

DEFAULT_CONFIGFILE = os.path.expanduser("~/.kofoto/config")
PRINT_GRAPH_INDENT = 4
_DIRECTORIES_TO_IGNORE = [".svn"]

######################################################################
### Exceptions.

class ArgumentError:
    pass

######################################################################
### Helper functions.

def displayHelp():
    sys.stdout.write(
#                                                                 79 characters here:  |
        "Usage: kofoto [flags] command [parameters]\n"
        "\n"
        "Flags:\n"
        "\n"
        "    -h, --help                       Display this help.\n"
        "        --configfile FILE            Use configuration file FILE instead of the\n"
        "                                     default (%s).\n"
        "    -l, --location LOCATION          Add/register to location LOCATION.\n"
        "                                     Default: last.\n"
        "        --shelf SHELF                Use the shelf SHELF instead of the default\n"
        "                                     (specified in the configuration file).\n"
        "    -v, --verbose                    Be verbose.\n"
        "    -t, --type TYPE                  Use album type TYPE when creating an album\n"
        "                                     or output type TYPE when generating output.\n"
        "    -V, --version                    Print version out standard output.\n"
        "\n"
        "Commands:\n"
        "\n"
        "    For shelfs\n"
        "    ==========\n"
        "    check                            Find missing images and print some\n"
        "                                     statistics.\n"
        "    create-album TAG                 Create an empty, unlinked album with tag\n"
        "                                     TAG. If a type argument is not given, an\n"
        "                                     album of type \"plain\" will be created.\n"
        "    create-shelf                     Create an empty shelf.\n"
        "    print-graph [ALBUM]              Print the album graph for ALBUM (default:\n"
        "                                     root).\n"
        "    rename-tag OLDTAG NEWTAG         Rename an album tag.\n"
        "    update-checksums                 Traverse all images in the shelf and\n"
        "                                     remember their new checksums.\n"
        "    update-locations DIR [DIR2 ...]  Traverse the given directories\n"
        "                                     recursively and remember the new\n"
        "                                     locations of images.\n"
        "\n"
        "    For albums and images\n"
        "    =====================\n"
        "\n"
        "    delete-attribute OBJ NAME        Delete attribute NAME for object OBJ.\n"
        "    get-attribute OBJ NAME           Get attribute NAME for object OBJ.\n"
        "    get-attributes OBJ               Get attributes for object OBJ.\n"
        "    obliterate OBJ [OBJ2 ...]        Delete object(s) permanently. All\n"
        "                                     metadata is also deleted.\n"
        "    remove ALBUM POS [POS2 ...]      Remove object(s) from ALBUM.\n"
        "    set-attribute OBJ NAME VALUE     Set attribute NAME to VALUE for object\n"
        "                                     OBJ.\n"
        "\n"
        "    For albums\n"
        "    ==========\n"
        "    add DEST OBJ1 [OBJ2 ...]         Add objects (albums and images)\n"
        "                                     to the album DEST. (The objects are placed\n"
        "                                     last.)\n"
        "    generate ALBUM DESTINATION       Generate output for ALBUM in DESTINATION.\n"
        "    register DEST PATH1 [PATH2 ...]  Register objects (i.e. directories and\n"
        "                                     images) and add them to the album DEST.\n"
        "                                     (The objects are placed last.)\n"
        "                                     Directories are recursively scanned for\n"
        "                                     other directories and images, which also\n"
        "                                     will be registered.\n"
        "\n"
        "    Miscellaneous\n"
        "    =============\n"
        "    clean-cache                      Clean up the image cache (remove\n"
        "                                     left-over generated images).\n"
        "\n"
        "Album types:\n"
        "\n"
        "    allalbums    All albums, sorted by tag.\n"
        "    allimages    All images, sorted by timestamp.\n"
        "    orphans      All albums and images that don't exist in any plain album.\n"
        "    plain        An ordinary container that holds albums and images.\n"
        "\n"
        % DEFAULT_CONFIGFILE)
#                                                                 79 characters here:  |


def printOutput(infoString):
    sys.stdout.write(infoString)

def printError(errorString):
    sys.stderr.write("Error: " + errorString)

def printErrorAndExit(errorString):
    printError(errorString)
    sys.exit(1)


######################################################################
### Commands.

def cmdAdd(env, args):
    if len(args) < 2:
        raise ArgumentError
    destalbum = env.shelf.getAlbum(args[0])
    objects = [env.shelf.getObject(x) for x in args[1:]]
    addHelper(env, destalbum, objects)


def addHelper(env, destalbum, objects):
    oldchildren = destalbum.getChildren()
    if env.location == -1:
        loc = len(oldchildren)
    else:
        loc = env.location
    destalbum.setChildren(oldchildren[:loc] + objects + oldchildren[loc:])


def cmdCheck(env, args):
    stats = env.shelf.getStatistics()
    env.out("Number of albums: %d\n" % stats["nalbums"])
    env.out("Number of images: %d\n" % stats["nimages"])
    badchecksums = []
    missingfiles = []
    for image in env.shelf.getAllImages():
        location = image.getLocation()
        if env.verbose:
            env.out("Checking %s ...\n" % location)
        try:
            realId = computeImageHash(location)
            storedId = image.getHash()
            if realId != storedId:
                badchecksums.append(location)
        except IOError:
            missingfiles.append(location)

    env.out("Missing images:")
    if badchecksums or missingfiles:
        for path in badchecksums:
            env.out("\n    (bad checksum) %s" % path)
        for path in missingfiles:
            env.out("\n    (missing) %s" % path)
        env.out("\n")
    else:
        env.out(" none\n")


def cmdCleanCache(env, args):
    if len(args) != 0:
        raise ArgumentError
    env.imagecache.cleanup(env.shelf.getAllImages(), env.imagesizes)


def cmdCreateAlbum(env, args):
    if len(args) != 1:
        raise ArgumentError
    if env.type:
        atype = env.type
    else:
        atype = "plain"
    env.shelf.createAlbum(args[0], atype)


def cmdDeleteAttribute(env, args):
    if len(args) != 2:
        raise ArgumentError
    object = env.shelf.getObject(args[0])
    object.deleteAttribute(args[1])


def cmdGenerate(env, args):
    if len(args) != 2:
        raise ArgumentError
    if env.type:
        otype = env.type
    else:
        otype = "crude"
    try:
        m = getattr(__import__("kofoto.output.%s" % otype).output, otype)
        root = env.shelf.getAlbum(args[0])
        og = m.OutputGenerator(env, root, args[1])
        albummap = {}
        imagemap = {}
        generateHelper(root, [], albummap, imagemap)
        while 1:
            if len(albummap) == 0:
                break
            tag, paths = albummap.popitem()
            og.generateAlbum(env.shelf.getAlbum(tag), paths)
        while 1:
            if len(imagemap) == 0:
                break
            hash, junk = imagemap.popitem()
            og.generateImage(env.shelf.getImage(hash))
    except ImportError:
        env.errexit("No such output module: %s\n" % otype)


def generateHelper(album, path, albummap, imagemap):
    if album.getTag() in [x.getTag() for x in path]:
        # Already visited album, so break recursion here.
        return
    path = path[:] + [album]
    tag = album.getTag()
    if not albummap.has_key(tag):
        albummap[tag] = []
    albummap[tag].append(path)
    for child in album.getChildren():
        if child.isAlbum():
            generateHelper(child, path, albummap, imagemap)
        else:
            imagemap[child.getHash()] = 1


def cmdGetAttribute(env, args):
    if len(args) != 2:
        raise ArgumentError
    object = env.shelf.getObject(args[0])
    value = object.getAttribute(args[1])
    if value:
        env.out(value + "\n")


def cmdGetAttributes(env, args):
    if len(args) != 1:
        raise ArgumentError
    object = env.shelf.getObject(args[0])
    for name in object.getAttributeNames():
        env.out("%s: %s\n" % (name, object.getAttribute(name)))


def cmdObliterate(env, args):
    if len(args) < 1:
        raise ArgumentError
    for obj in args:
        env.shelf.deleteObject(obj)


def cmdPrintGraph(env, args):
    if len(args) > 0:
        root = env.shelf.getAlbum(args[0])
    else:
        root = env.shelf.getRootAlbum()
    printGraphHelper(env, root, 0, [])


def printGraphHelper(env, object, level, visited):
    imgtmpl = "%(indent)s[I] %(name)s <%(id)s>\n"
    albtmpl = "%(indent)s[A] %(name)s <%(id)s> (%(type)s)\n"
    indentspaces = PRINT_GRAPH_INDENT * " "
    if object.isAlbum():
        tag = object.getTag()
        env.out(albtmpl % {"indent": level * indentspaces,
                           "name": tag,
                           "id": object.getId(),
                           "type": object.getType(),
                           })
        if tag in visited:
            env.out("%s[...]\n" % ((level + 1) * indentspaces))
        else:
            for child in object.getChildren():
                printGraphHelper(env,
                                 child,
                                 level + 1,
                                 visited + [tag])
    else:
        env.out(imgtmpl % {"indent": level * indentspaces,
                           "name": object.getLocation(),
                           "id": object.getId(),
                           })
    if env.verbose:
        attrtmpl = "%(indent)s%(key)s: %(value)s\n"
        names = object.getAttributeNames()
        for name in names:
            env.out(attrtmpl % {"indent": (level + 1) * indentspaces,
                                "key": name,
                                "value": object.getAttribute(name),
                                })


def cmdRegister(env, args):
    if len(args) < 2:
        raise ArgumentError
    destalbum = env.shelf.getAlbum(args[0])
    registerHelper(env, destalbum, args[1:])


def registerHelper(env, destalbum, paths):
    paths.sort()
    newchildren = []
    for path in paths:
        if env.verbose:
            env.out("Processing %s ...\n" % path)
        if os.path.isdir(path):
            tag = os.path.basename(path)
            if tag in _DIRECTORIES_TO_IGNORE:
                if env.verbose:
                    env.out("Ignoring.\n")
                continue
            while 1:
                try:
                    album = env.shelf.createAlbum(tag)
                    break
                except (AlbumExistsError, ReservedAlbumTagError):
                    tag = tag + "_"
            newchildren.append(album)
            env.out("Registered directory %s as an album with tag %s\n" % (path, tag))
            registerHelper(env,
                           album,
                           [os.path.join(path, x) for x in os.listdir(path)])
        elif os.path.isfile(path):
            try:
                image = env.shelf.createImage(path)
                newchildren.append(image)
                if env.verbose:
                    env.out("Registered image: %s\n" % path)
            except NotAnImageError, x:
                if env.verbose:
                    env.out("Ignoring non-image file: %s\n" % path)
            except ImageExistsError, x:
                env.err("Ignoring already registered image: %s\n" % path)
        else:
            env.err("No such file or directory (ignored): %s\n" % path)
    addHelper(env, destalbum, newchildren)


def cmdRemove(env, args):
    if len(args) < 2:
        raise ArgumentError
    album = env.shelf.getAlbum(args[0])
    positions = []
    for pos in args[1:]:
        try:
            positions.append(int(pos))
        except ValueError:
            env.errexit("Bad position: %s\n" % pos)
    positions.sort()
    positions.reverse()
    children = album.getChildren()
    if not (0 <= positions[0] < len(children)):
        env.errexit("Bad position: %s\n" % positions[0])
    for pos in positions:
        del children[pos]
    album.setChildren(children)


def cmdRenameTag(env, args):
    if len(args) < 2:
        raise ArgumentError
    env.shelf.getAlbum(args[0]).setTag(args[1])


def cmdSetAttribute(env, args):
    if len(args) != 3:
        raise ArgumentError
    object = env.shelf.getObject(args[0])
    object.setAttribute(args[1], args[2])


def cmdUpdateChecksums(env, args):
    for image in env.shelf.getAllImagesAlbum().getChildren():
        location = image.getLocation()
        if os.path.isfile(location):
            try:
                hash = computeImageHash(location)
                oldhash = image.getHash()
                if oldhash != hash:
                    image.setHash(hash)
                    env.out("New checksum for %s\n" % location)
                else:
                    if env.verbose:
                        env.out("Same checksum as before for %s\n" % location)
            except IOError, x:
                env.err("Failed to read: %s\n" % location)
        else:
            env.err("Image does not exist: %s\n" % location)


def cmdUpdateLocations(env, args):
    if len(args) < 1:
        raise ArgumentError
    for dir in args:
        os.path.walk(os.path.abspath(dir),
                     updateLocationsHelper,
                     env)


def updateLocationsHelper(env, dir, files):
    for x in _DIRECTORIES_TO_IGNORE:
        files.remove(x)
    for file in files:
        location = os.path.join(dir, file)
        if os.path.isfile(location):
            try:
                hash = computeImageHash(location)
                image = env.shelf.getImage(hash)
                oldlocation = image.getLocation()
                if oldlocation != location:
                    image.setLocation(location)
                    env.out("New location: %s --> %s\n" % (oldlocation,
                                                           location))
                else:
                    if env.verbose:
                        env.out("Same location as before: %s\n" % location)
            except IOError, x:
                if env.verbose:
                    env.out("Failed to read: %s\n" % location)
            except ImageDoesNotExistError, x:
                if env.verbose:
                    env.out("Image does not exist: %s\n" % location)


commandTable = {
    "add": cmdAdd,
    "check": cmdCheck,
    "clean-cache": cmdCleanCache,
    "create-album": cmdCreateAlbum,
    "delete-attribute": cmdDeleteAttribute,
    "generate": cmdGenerate,
    "get-attribute": cmdGetAttribute,
    "get-attributes": cmdGetAttributes,
    "obliterate": cmdObliterate,
    "print-graph": cmdPrintGraph,
    "register": cmdRegister,
    "remove": cmdRemove,
    "rename-tag": cmdRenameTag,
    "set-attribute": cmdSetAttribute,
    "update-checksums": cmdUpdateChecksums,
    "update-locations": cmdUpdateLocations,
}

######################################################################
### Help functions.

def readConfig(configFilename):
    globals = {}
    conf = {}
    try:
        execfile(configFilename, globals, conf)
    except SyntaxError, x:
        printErrorAndExit(
            "Could not parse %s: %s\n" % (configFilename, str(x)) +
            "It must executable Python code.\n")
    except IOError, x:
        printErrorAndExit(
            "Error while reading %s: %s.\n" % (configFilename, repr(x[1])))

    checkConfigurationItem(
        conf, "shelf_location", lambda x: type(x) == type(""))
    checkConfigurationItem(
        conf, "imagecache_location", lambda x: type(x) == type(""))
    checkConfigurationItem(
        conf, "thumbnail_image_size", lambda x: type(x) == type(1))
    checkConfigurationItem(
        conf, "default_image_size", lambda x: type(x) == type(1))
    checkConfigurationItem(
        conf,
        "other_image_sizes",
        lambda x: (type(x) == type([]) and
                   len([y for y in x if type(y) != type(1)]) == 0))
    return conf

def checkConfigurationItem(conf, key, function):
    if not conf.has_key(key):
        printErrorAndExit("Missing configuration item: %s.\n" % key)
    if not function(conf[key]):
        printErrorAndExit("Configuration item has bad value: %s.\n" % key)


######################################################################
### Main

def main(argv):
    try:
        optlist, args = getopt.getopt(
            argv[1:],
            "hl:t:vV",
            ["configfile=",
             "help",
             "location=",
             "shelf=",
             "type=",
             "verbose",
             "version"])
    except getopt.GetoptError:
        printErrorAndExit("Unknown flag. See \"kofoto --help\" for help.\n")

    class CommandEnvironment:
        pass
    env = CommandEnvironment()
    env.location = -1
    env.verbose = 0
    env.type = None

    shelfLocation = None
    configFilename = DEFAULT_CONFIGFILE
    for opt, optarg in optlist:
        if opt == "--configfile":
            configFilename = optarg
        elif opt in ("-h", "--help"):
            displayHelp()
            sys.exit(0)
        elif opt in ("-l", "--location"):
            if optarg == "last":
                env.location = -1
            else:
                try:
                    env.location = int(optarg)
                except ValueError:
                    printErrorAndExit("Invalid location: \"%s\"\n" % optarg)
        elif opt == "--shelf":
            shelfLocation = optarg
        elif opt in ("-t", "--type"):
            env.type = optarg
        elif opt in ("-v", "--verbose"):
            env.verbose = 1
        elif opt in ("-V", "--version"):
            sys.stdout.write("crowbar\n")
            sys.exit(0)

    if len(args) == 0:
        printErrorAndExit(
            "No command given. See \"kofoto --help\" for help.\n")

    if not os.path.exists(configFilename):
        confdir = os.path.dirname(configFilename)
        if confdir and not os.path.exists(confdir):
            os.mkdir(confdir)
            sys.stdout.write("Created directory \"%s\".\n" % confdir)
        file = open(configFilename, "w")
        file.write(
            "# Configuration file for Kofoto. (This is -*- Python -*- code.)\n"
            "\n"
            "# Default location of the shelf. This is where information about\n"
            "# albums and images is stored.\n"
            "shelf_location = \"~/.kofoto/shelf\"\n"
            "\n"
            "# Default location of the image cache. This is where generated images\n"
            "# images are stored.\n"
            "imagecache_location = \"~/.kofoto/imagecache\"\n"
            "\n"
            "# Size of thumbnails.\n"
            "thumbnail_image_size = 128\n"
            "\n"
            "# The image size that will be used when first entering an album.\n"
            "default_image_size = 640\n"
            "\n"
            "# A list of image sizes (other than thumbnail_image_size and\n"
            "# default_image_size) to include in albums.\n"
            "other_image_sizes = [400, 1024]\n")
        file.close()
        sys.stdout.write("Created configuration file \"%s\".\n" %
                         configFilename)
        sys.exit(0)

    conf = readConfig(configFilename)

    if not shelfLocation and conf.has_key("shelf_location"):
        shelfLocation = conf["shelf_location"]
    if shelfLocation:
        shelfLocation = os.path.expanduser(shelfLocation)
    else:
        printErrorAndExit(
            ("Don't know which shelf to use; none defined in %s and no\n" +
             "--shelf parameter given.\n") % configFilename)

    if args[0] == "create-shelf":
        try:
            Shelf(shelfLocation, create=1)
        except FailedWritingError, filename:
            printErrorAndExit(
                "Could not create shelf file %s (already exists?).\n" %
                filename)
        sys.exit(0)

    if not commandTable.has_key(args[0]):
        printErrorAndExit(
            "Unknown command \"%s\". See \"kofoto --help\" for help.\n" %
            args[0])

    try:
        shelf = Shelf(shelfLocation)
    except ShelfNotFoundError, x:
        printErrorAndExit(
            "Could not open shelf \"%s\".\n" % shelfLocation +
            "You can create a new one by running " +
            "\"kofoto create-shelf\"\n")
    except ShelfLockedError, x:
        printErrorAndExit(
            "Could not open shelf \"%s\".\n" % shelfLocation +
            "Another process is locking it.\n")
    shelf.begin()
    try:
        env.out = printOutput
        env.err = printError
        env.errexit = printErrorAndExit
        env.shelf = shelf
        env.imagecache = ImageCache(
            os.path.expanduser(conf["imagecache_location"]))
        env.thumbnailsize = conf["thumbnail_image_size"]
        env.defaultsize = conf["default_image_size"]
        sizes = []
        sizes.append(conf["thumbnail_image_size"])
        sizes.append(conf["default_image_size"])
        sizes.extend(conf["other_image_sizes"])
        sizes.sort()
        env.imagesizes = sizes

        commandTable[args[0]](env, args[1:])
        shelf.commit()
        sys.exit(0)
    except ArgumentError:
        printErrorAndExit(
            "Bad arguments to command. See \"kofoto --help\" for help.\n")
    except UndeletableAlbumError, x:
        printError("Undeletable album: \"%s\".\n" % x)
    except ReservedAlbumTagError, x:
        printError("Reserved album tag: \"%s\".\n" % x)
    except AlbumExistsError, x:
        printError("Album already exists: \"%s\".\n" % x)
    except ImageDoesNotExistError, x:
        printError("Image does not exist: \"%s\".\n" % x)
    except AlbumDoesNotExistError, x:
        printError("Album does not exist: \"%s\".\n" % x)
    except ObjectDoesNotExistError, x:
        printError("Object does not exist: \"%s\".\n" % x)
    except UnknownAlbumTypeError, x:
        printError("Unknown album type: \"%s\".\n" % x)
    except UnsettableChildrenError, x:
        printError("Cannot add children to \"%s\" (children are created virtually).\n" % x)
    except KeyboardInterrupt:
        printOutput("Interrupted.\n")
    shelf.rollback()
    sys.exit(1)


######################################################################
### Main.

if __name__ == "__main__":
    main(sys.argv)
