#! /usr/bin/env python

import getopt
import locale
import os
from sets import Set
import sys
import time

######################################################################

# Find libraries if installed in ../lib (like in the source tree).
if os.path.islink(sys.argv[0]):
    link = os.readlink(sys.argv[0])
    absloc = os.path.normpath(
        os.path.join(os.path.dirname(sys.argv[0]), link))
    bindir = os.path.dirname(absloc)
else:
    bindir = os.path.dirname(sys.argv[0])
sys.path.insert(0, os.path.join(bindir, "..", "lib"))

from kofoto.clientenvironment import *
from kofoto.clientutils import *
from kofoto.common import *
from kofoto.config import *
from kofoto.imagecache import *
from kofoto.search import *
from kofoto.shelf import *

######################################################################
### Constants.

PRINT_ALBUMS_INDENT = 4

######################################################################
### Exceptions.

class ArgumentError:
    pass

######################################################################
### Helper functions.

def displayHelp():
    sys.stdout.write(
#                                                                 79 characters here:  |
        "Usage: kofoto [flags] command [parameters]\n"
        "\n"
        "Flags:\n"
        "\n"
        "    -h, --help                       Display this help.\n"
        "        --configfile FILE            Use configuration file FILE instead of the\n"
        "                                     default (%s).\n"
        "        --database DATABASE          Use the metadata database DATABASE instead\n"
        "                                     of the default (specified in the\n"
        "                                     configuration file).\n"
        "        --gencharenc ENC             Generate HTML pages with character\n"
        "                                     encoding ENC instead of the default\n"
        "                                     (taken from locale settings).\n"
        "        --ids                        Print ID numbers instead of locations.\n"
        "    -l, --location LOCATION          Add/register to location LOCATION.\n"
        "                                     Default: last.\n"
        "        --no-act                     Do everything which is supposed to be done,\n"
        "                                     but don't commit any changes to the\n"
        "                                     database.\n"
        "    -t, --type TYPE                  Use album type TYPE when creating an album\n"
        "                                     or output type TYPE when generating output.\n"
        "    -v, --verbose                    Be verbose (and slower).\n"
        "    -V, --version                    Print version to standard output.\n"
        "\n"
        "Commands:\n"
        "\n"
        "    For databases\n"
        "    =============\n"
        "    check                            Find missing images and print some\n"
        "                                     statistics.\n"
        "    create-album TAG                 Create an empty, unlinked album with tag\n"
        "                                     TAG. If a type argument is not given\n"
        "                                     with -t/--type, an album of type \"plain\"\n"
        "                                     will be created.\n"
        "    print-albums [ALBUM]             Print the album graph for ALBUM (default:\n"
        "                                     root). If -v/--verbose is given, also print\n"
        "                                     images and attributes.\n"
        "    rename-tag OLDTAG NEWTAG         Rename an album tag.\n"
        "    update-contents PATH [PATH ...]  Traverse the given paths recursively and\n"
        "                                     remember the new contents (checksum, width\n"
        "                                     and height) of found images.\n"
        "    update-locations PATH [PATH ...] Traverse the given paths recursively and\n"
        "                                     remember the new locations of found images.\n"
        "\n"
        "    For albums and images\n"
        "    =====================\n"
        "\n"
        "    add-category CAT OBJ [OBJ ...]   Add category CAT (tag or ID) to the given\n"
        "                                     objects.\n"
        "    delete-attribute NAME OBJ [OBJ ...]\n"
        "                                     Delete attribute NAME for the given\n"
        "                                     objects.\n"
        "    get-attribute NAME OBJ           Get attribute NAME for object OBJ.\n"
        "    get-attributes OBJ               Get attributes for object OBJ.\n"
        "    get-categories OBJ               Get categories for object OBJ.\n"
        "    obliterate OBJ [OBJ ...]         Delete the given objects permanently. All\n"
        "                                     metadata is also deleted.\n"
        "    remove-category CAT OBJ [OBJ ...]\n"
        "                                     Remove category CAT from the given\n"
        "                                     objects.\n"
        "    search EXPR                      Search for images matching an expression.\n"
        "    set-attribute NAME VALUE OBJ [OBJ ...]\n"
        "                                     Set attribute NAME to VALUE for the given\n"
        "                                     objects.\n"
        "\n"
        "    For albums\n"
        "    ==========\n"
        "    add DEST OBJ [OBJ ...]           Add the given objects (albums and images)\n"
        "                                     to the album DEST. (The objects are placed\n"
        "                                     last if a location is not specified with\n"
        "                                     -l/--location.)\n"
        "    generate ROOTALBUM DEST [SUBALBUM ...]\n"
        "                                     Generate output for ROOTALBUM in\n"
        "                                     the directory DEST. If subalbums are given,\n"
        "                                     only generate those albums, their\n"
        "                                     descendants and their immediate parents.\n"
        "                                     Use -t/--type to use another output type\n"
        "                                     than the default.\n"
        "    register DEST PATH [PATH ...]    Register objects (i.e. directories and\n"
        "                                     images) and add them to the album DEST.\n"
        "                                     (The objects are placed last.)\n"
        "                                     Directories are recursively scanned for\n"
        "                                     other directories and images, which also\n"
        "                                     will be registered.\n"
        "    remove ALBUM POS [POS ...]       Remove the given objects from ALBUM.\n"
        "    sort ALBUM [ATTR]                Sort the contents of ALBUM by the\n"
        "                                     attribute named ATTR (default: captured).\n"
        "\n"
        "    For images\n"
        "    ==========\n"
        "    inspect-locations PATH [PATH ...]\n"
        "                                     Traverse the given paths and print whether\n"
        "                                     each found file is a registered, modified,\n"
        "                                     moved or unregistered image or a non-image.\n"
        "\n"
        "    For categories\n"
        "    ==============\n"
        "    connect-category PARENT CHILD    Make a category a child of another\n"
        "                                     category.\n"
        "    disconnect-category PARENT CHILD Remove parent-child realationship bewteen\n"
        "                                     two categories.\n"
        "    create-category TAG DESC         Create category.\n"
        "    obliterate-category TAG          Delete category permanently.\n"
        "    print-categories                 Print category tree.\n"
        "    rename-category OLDTAG NEWTAG    Rename category tag.\n"
        "    set-category-description TAG DESC\n"
        "                                     Set category description.\n"
        "\n"
        "    Miscellaneous\n"
        "    =============\n"
        "    clean-cache                      Clean up the image cache (remove\n"
        "                                     left-over generated images).\n"
        "\n"
        "Album types:\n"
        "\n"
        "    Type         Description\n"
        "    ------------------------\n"
        "    allalbums    All albums, sorted by tag.\n"
        "    allimages    All images, sorted by capture timestamp.\n"
        "    orphans      All albums and images that don't exist in any plain album.\n"
        "    plain        An ordinary container that holds albums and images.\n"
        "    search       An album containing the albums and images that match a search\n"
        "                 string (sorted by capture timestamp). The search string is\n"
        "                 read from the album's \"query\" attribute.\n"
        "\n"
        % DEFAULT_CONFIGFILE_LOCATION)
#                                                                 79 characters here:  |


def printOutput(infoString):
    sys.stdout.write(infoString)
    sys.stdout.flush()

def printNotice(noticeString):
    sys.stderr.write("Notice: " + noticeString)

def printError(errorString):
    sys.stderr.write("Error: " + errorString)

def printErrorAndExit(errorString):
    printError(errorString)
    sys.exit(1)


######################################################################
### Helper classes.

class CommandlineClientEnvironment(ClientEnvironment):
    to_l = ClientEnvironment.unicodeToLocalizedString
    to_u = ClientEnvironment.localizedStringToUnicode

    def _writeInfo(self, info):
        printNotice(info)

######################################################################
### Commands.

def cmdAdd(env, args):
    if len(args) < 2:
        raise ArgumentError
    destalbum = env.shelf.getAlbum(args[0])
    objects = [env.shelf.getObject(x) for x in args[1:]]
    addHelper(env, destalbum, objects)


def addHelper(env, destalbum, objects):
    oldchildren = list(destalbum.getChildren())
    if env.location == -1:
        loc = len(oldchildren)
    else:
        loc = env.location
    destalbum.setChildren(oldchildren[:loc] + objects + oldchildren[loc:])


def cmdAddCategory(env, args):
    if len(args) < 2:
        raise ArgumentError
    category = env.shelf.getCategory(args[0])
    for arg in args[1:]:
        env.shelf.getObject(arg).addCategory(category)


def cmdCheck(env, args):
    stats = env.shelf.getStatistics()
    env.out("Number of albums: %d\n" % stats["nalbums"])
    env.out("Number of images: %d\n" % stats["nimages"])
    badchecksums = []
    missingfiles = []
    for image in env.shelf.getAllImages():
        location = env.to_l(image.getLocation())
        if env.verbose:
            env.out("Checking %s ...\n" % location)
        try:
            realId = computeImageHash(location)
            storedId = image.getHash()
            if realId != storedId:
                badchecksums.append(location)
        except IOError:
            missingfiles.append(location)

    env.out("Missing images:")
    if badchecksums or missingfiles:
        for path in badchecksums:
            env.out("\n    (bad checksum) %s" % path)
        for path in missingfiles:
            env.out("\n    (missing) %s" % path)
        env.out("\n")
    else:
        env.out(" none\n")


def cmdCleanCache(env, args):
    if env.noAct:
        raise ArgumentError
    if len(args) != 0:
        raise ArgumentError
    env.imageCache.cleanup()


def cmdConnectCategory(env, args):
    if len(args) != 2:
        raise ArgumentError
    parent = env.shelf.getCategory(args[0])
    child = env.shelf.getCategory(args[1])
    parent.connectChild(child)


def cmdCreateAlbum(env, args):
    if len(args) != 1:
        raise ArgumentError
    if env.type:
        atype = env.type
    else:
        atype = u"plain"
    env.shelf.createAlbum(args[0], atype)


def cmdCreateCategory(env, args):
    if len(args) != 2:
        raise ArgumentError
    env.shelf.createCategory(args[0], args[1])


def cmdDeleteAttribute(env, args):
    if len(args) < 2:
        raise ArgumentError
    attr = args[0]
    for arg in args[1:]:
        env.shelf.getObject(arg).deleteAttribute(attr)


def cmdDisconnectCategory(env, args):
    if len(args) != 2:
        raise ArgumentError
    parent = env.shelf.getCategory(args[0])
    child = env.shelf.getCategory(args[1])
    parent.disconnectChild(child)


def cmdGenerate(env, args):
    if len(args) < 2:
        raise ArgumentError
    root = env.shelf.getAlbum(args[0])
    dest = args[1]
    subalbums = [env.shelf.getAlbum(x) for x in args[2:]]
    if env.type:
        otype = env.type
    else:
        otype = u"woolly"
    import kofoto.generate
    try:
        generator = kofoto.generate.Generator(otype, env)
        generator.generate(root, subalbums, dest, env.gencharenc)
    except kofoto.generate.OutputTypeError, x:
        env.errexit("No such output module: %s\n" % env.to_l(x))


def cmdGetAttribute(env, args):
    if len(args) != 2:
        raise ArgumentError
    object = env.shelf.getObject(args[1])
    value = object.getAttribute(args[0])
    if value:
        env.out(env.to_l(value) + "\n")


def cmdGetAttributes(env, args):
    if len(args) != 1:
        raise ArgumentError
    object = env.shelf.getObject(args[0])
    for name in object.getAttributeNames():
        env.out("%s: %s\n" % (env.to_l(name),
                              env.to_l(object.getAttribute(name))))


def cmdGetCategories(env, args):
    if len(args) != 1:
        raise ArgumentError
    object = env.shelf.getObject(args[0])
    for category in object.getCategories():
        env.out("%s (%s) <%s>\n" % (env.to_l(category.getDescription()),
                                    env.to_l(category.getTag()),
                                    category.getId()))

def cmdInspectLocations(env, args):
    if len(args) < 1:
        raise ArgumentError
    import Image as PILImage
    for filepath in walk_files(args):
        try:
            image = env.shelf.getImage(filepath)
            if image.getLocation() == os.path.realpath(filepath):
                env.out("[Registered]   %s\n" % env.to_l(filepath))
            else:
                env.out("[Moved]        %s\n" % env.to_l(filepath))
        except ImageDoesNotExistError:
            try:
                image = env.shelf.getImage(
                    filepath, identifyByLocation=True)
                env.out("[Modified]     %s\n" % env.to_l(filepath))
            except MultipleImagesAtOneLocationError:
                env.out("[Multiple]     %s\n" % env.to_l(filepath))
            except ImageDoesNotExistError:
                try:
                    PILImage.open(env.to_l(filepath))
                    env.out("[Unregistered] %s\n" % env.to_l(filepath))
#                except IOError:
                except: # Work-around for buggy PIL.
                    env.out("[Non-image]    %s\n" % env.to_l(filepath))


def cmdObliterate(env, args):
    if len(args) < 1:
        raise ArgumentError
    for obj in args:
        env.shelf.deleteObject(obj)


def cmdObliterateCategory(env, args):
    if len(args) != 1:
        raise ArgumentError
    env.shelf.deleteCategory(args[0])


def cmdPrintAlbums(env, args):
    if len(args) > 0:
        root = env.shelf.getAlbum(args[0])
    else:
        root = env.shelf.getRootAlbum()
    printAlbumsHelper(env, root, 0, 0, [])


def printAlbumsHelper(env, object, position, level, visited):
    imgtmpl = "%(indent)s[I] %(name)s {%(position)s} <%(id)s>\n"
    if env.verbose:
        albtmpl = "%(indent)s[A] %(name)s {%(position)s} <%(id)s> (%(type)s)\n"
    else:
        albtmpl = "%(indent)s[A] %(name)s <%(id)s> (%(type)s)\n"
    indentspaces = PRINT_ALBUMS_INDENT * " "
    if object.isAlbum():
        tag = object.getTag()
        env.out(albtmpl % {"indent": level * indentspaces,
                           "name": env.to_l(tag),
                           "position": position,
                           "id": object.getId(),
                           "type": env.to_l(object.getType()),
                           })
        if tag in visited:
            env.out("%s[...]\n" % ((level + 1) * indentspaces))
        else:
            pos = 0
            if env.verbose:
                children = object.getChildren()
            else:
                children = object.getAlbumChildren()
            for child in children:
                printAlbumsHelper(
                    env,
                    child,
                    pos,
                    level + 1,
                    visited + [tag])
                pos += 1
    else:
        env.out(imgtmpl % {"indent": level * indentspaces,
                           "name": env.to_l(object.getLocation()),
                           "position": position,
                           "id": object.getId(),
                           })
    if env.verbose:
        attrtmpl = "%(indent)s%(key)s: %(value)s\n"
        names = object.getAttributeNames()
        for name in names:
            env.out(attrtmpl % {
                "indent": (level + 1) * indentspaces,
                "key": env.to_l(name),
                "value": env.to_l(object.getAttribute(name)),
                })


def cmdPrintCategories(env, args):
    if len(args) != 0:
        raise ArgumentError
    for category in env.shelf.getRootCategories():
        printCategoriesHelper(env, category, 0)


def printCategoriesHelper(env, category, level):
    indentspaces = PRINT_ALBUMS_INDENT * " "
    env.out("%s%s (%s) <%s>\n" % (
        level * indentspaces,
        env.to_l(category.getDescription()),
        env.to_l(category.getTag()),
        category.getId()))
    for child in category.getChildren():
        printCategoriesHelper(env, child, level + 1)


def cmdRegister(env, args):
    if len(args) < 2:
        raise ArgumentError
    destalbum = env.shelf.getAlbum(args[0])
    registrationTimeString = unicode(time.strftime("%Y-%m-%d %H:%M:%S"))
    registerHelper(
        env,
        destalbum,
        registrationTimeString,
        [env.to_l(x) for x in args[1:]])


def registerHelper(env, destalbum, registrationTimeString, paths):
    paths.sort()
    newchildren = []
    for path in paths:
        if env.verbose:
            env.out("Processing %s ...\n" % path)
        if os.path.isdir(path):
            tag = os.path.basename(path)
            if tag in DIRECTORIES_TO_IGNORE:
                if env.verbose:
                    env.out("Ignoring.\n")
                continue
            tag = makeValidTag(tag)
            while True:
                try:
                    album = env.shelf.createAlbum(env.to_u(tag))
                    break
                except AlbumExistsError:
                    tag += "_"
            newchildren.append(album)
            env.out("Registered directory %s as an album with tag %s\n" % (
                path,
                tag))
            registerHelper(
                env,
                album,
                registrationTimeString,
                [os.path.join(path, x) for x in os.listdir(path)])
        elif os.path.isfile(path):
            try:
                image = env.shelf.createImage(env.to_u(path))
                image.setAttribute(u"registered", registrationTimeString)
                newchildren.append(image)
                if env.verbose:
                    env.out("Registered image: %s\n" % path)
            except NotAnImageError, x:
                env.out("Ignoring non-image file: %s\n" % path)
            except ImageExistsError, x:
                env.err("Ignoring already registered image: %s\n" % path)
        else:
            env.err("No such file or directory (ignored): %s\n" % path)
    addHelper(env, destalbum, newchildren)


def cmdRemove(env, args):
    if len(args) < 2:
        raise ArgumentError
    album = env.shelf.getAlbum(args[0])
    positions = []
    for pos in args[1:]:
        try:
            positions.append(int(pos))
        except ValueError:
            env.errexit("Bad position: %s.\n" % env.to_l(pos))
    positions.sort()
    positions.reverse()
    children = list(album.getChildren())
    if not (0 <= positions[0] < len(children)):
        env.errexit("Bad position: %d.\n" % positions[0])
    for pos in positions:
        del children[pos]
    album.setChildren(children)


def cmdRemoveCategory(env, args):
    if len(args) < 2:
        raise ArgumentError
    category = env.shelf.getCategory(args[0])
    for arg in args[1:]:
        env.shelf.getObject(arg).removeCategory(category)


def cmdRenameCategory(env, args):
    if len(args) != 2:
        raise ArgumentError
    env.shelf.getCategory(args[0]).setTag(args[1])


def cmdRenameTag(env, args):
    if len(args) != 2:
        raise ArgumentError
    env.shelf.getAlbum(args[0]).setTag(args[1])


def cmdSearch(env, args):
    if len(args) != 1:
        raise ArgumentError
    parser = Parser(env.shelf)
    objects = env.shelf.search(parser.parse(args[0]))
    if env.printIDs:
        ids = [str(x.getId()) for x in objects if not x.isAlbum()]
        if ids:
            env.out(" ".join(ids) + "\n")
    else:
        locations = [env.to_l(x.getLocation()) for x in objects if not x.isAlbum()]
        if locations:
            env.out("\n".join(locations) + "\n")


def cmdSetAttribute(env, args):
    if len(args) < 3:
        raise ArgumentError
    attr = args[0]
    value = args[1]
    for arg in args[2:]:
        env.shelf.getObject(arg).setAttribute(attr, value)


def cmdSetCategoryDescription(env, args):
    if len(args) != 2:
        raise ArgumentError
    env.shelf.getCategory(args[0]).setDescription(args[1])


def cmdSort(env, args):
    if not 1 <= len(args) <= 2:
        raise ArgumentError
    if len(args) == 2:
        attr = args[1]
    else:
        attr = u"captured"
    album = env.shelf.getAlbum(args[0])
    children = list(album.getChildren())
    children.sort(
        lambda x, y: cmp(x.getAttribute(attr), y.getAttribute(attr)))
    album.setChildren(children)


def cmdUpdateContents(env, args):
    if len(args) < 1:
        raise ArgumentError
    for filepath in walk_files(args):
        try:
            image = env.shelf.getImage(
                filepath, identifyByLocation=True)
            oldhash = image.getHash()
            image.contentChanged()
            if image.getHash() != oldhash:
                env.out("New checksum: %s\n" % env.to_l(filepath))
            else:
                if env.verbose:
                    env.out("Same checksum as before: %s\n" %
                            env.to_l(filepath))
        except ImageDoesNotExistError:
            if env.verbose:
                env.out("Unregistered image/file: %s\n" % env.to_l(filepath))
        except MultipleImagesAtOneLocationError:
            env.errexit(
                "Multiple known images at this location: %s\n",
                env.to_l(filepath))


def cmdUpdateLocations(env, args):
    if len(args) < 1:
        raise ArgumentError
    for filepath in walk_files(args):
        try:
            image = env.shelf.getImage(filepath)
            oldlocation = image.getLocation()
            if oldlocation != os.path.realpath(filepath):
                image.locationChanged(filepath)
                env.out("New location: %s --> %s\n" % (
                    env.to_l(oldlocation),
                    env.to_l(image.getLocation())))
            else:
                if env.verbose:
                    env.out("Same location as before: %s\n" %
                            env.to_l(filepath))
        except IOError, x:
            if env.verbose:
                env.out("Failed to read: %s\n" % env.to_l(filepath))
        except ImageDoesNotExistError:
            if env.verbose:
                env.out("Unregistered image/file: %s\n" % env.to_l(filepath))


commandTable = {
    "add": cmdAdd,
    "add-category": cmdAddCategory,
    "check": cmdCheck,
    "clean-cache": cmdCleanCache,
    "connect-category": cmdConnectCategory,
    "create-album": cmdCreateAlbum,
    "create-category": cmdCreateCategory,
    "delete-attribute": cmdDeleteAttribute,
    "disconnect-category": cmdDisconnectCategory,
    "generate": cmdGenerate,
    "get-attribute": cmdGetAttribute,
    "get-attributes": cmdGetAttributes,
    "get-categories": cmdGetCategories,
    "inspect-locations": cmdInspectLocations,
    "obliterate": cmdObliterate,
    "obliterate-category": cmdObliterateCategory,
    "print-albums": cmdPrintAlbums,
    "print-categories": cmdPrintCategories,
    "register": cmdRegister,
    "remove": cmdRemove,
    "remove-category": cmdRemoveCategory,
    "rename-category": cmdRenameCategory,
    "rename-tag": cmdRenameTag,
    "search": cmdSearch,
    "set-attribute": cmdSetAttribute,
    "set-category-description": cmdSetCategoryDescription,
    "sort": cmdSort,
    "update-contents": cmdUpdateContents,
    "update-locations": cmdUpdateLocations,
}

######################################################################
### Main

def main(argv):
    env = CommandlineClientEnvironment()

    argv = [env.to_u(x) for x in argv]
    try:
        optlist, args = getopt.gnu_getopt(
            argv[1:],
            "hl:t:vV",
            ["database=",
             "configfile=",
             "gencharenc=",
             "help",
             "ids",
             "location=",
             "no-act",
             "type=",
             "verbose",
             "version"])
    except getopt.GetoptError:
        printErrorAndExit("Unknown flag. See \"kofoto --help\" for help.\n")

    env.printIDs = False
    env.location = -1
    env.noAct = False
    env.verbose = False
    env.type = None

    shelfLocation = None
    configFileLocation = None
    genCharEnc = env.codeset
    for opt, optarg in optlist:
        if opt == "--configfile":
            configFileLocation = os.path.expanduser(env.to_l(optarg))
        elif opt == "--database":
            shelfLocation = env.to_l(optarg)
        elif opt == "--gencharenc":
            genCharEnc = str(optarg)
        elif opt in ("-h", "--help"):
            displayHelp()
            sys.exit(0)
        elif opt == "--ids":
            env.printIDs = True
        elif opt in ("-l", "--location"):
            if optarg == "last":
                env.location = -1
            else:
                try:
                    env.location = int(optarg)
                except ValueError:
                    printErrorAndExit("Invalid location: \"%s\"\n" %
                                      env.to_l(optarg))
        elif opt in ("-t", "--type"):
            env.type = optarg
        elif opt in ("-v", "--verbose"):
            env.verbose = True
        elif opt in ("-V", "--version"):
            sys.stdout.write("%s\n" % env.version)
            sys.exit(0)
        elif opt == "--no-act":
            sys.stdout.write("no-act: No changes will be commited to the database!\n")
            env.noAct = True

    if len(args) == 0:
        printErrorAndExit(
            "No command given. See \"kofoto --help\" for help.\n")

    try:
        env.setup(configFileLocation, shelfLocation)
    except ClientEnvironmentError, e:
        printErrorAndExit(e[0])

    if not commandTable.has_key(args[0]):
        printErrorAndExit(
            "Unknown command \"%s\". See \"kofoto --help\" for help.\n" %
            env.to_l(args[0]))

    try:
        env.shelf.begin()
    except ShelfNotFoundError, x:
        printErrorAndExit("Could not open metadata database \"%s\".\n" % (
            env.shelfLocation))
    except ShelfLockedError, x:
        printErrorAndExit(
            "Could not open metadata database \"%s\".\n" % env.shelfLocation +
            "Another process is locking it.\n")
    except UnsupportedShelfError, filename:
        printErrorAndExit(
            "Could not read metadata database file %s (too new database format?).\n" %
            filename)
    try:
        env.gencharenc = genCharEnc
        env.out = printOutput
        env.err = printError
        env.errexit = printErrorAndExit
        env.thumbnailsizelimit = env.config.getcoordlist(
            "album generation", "thumbnail_size_limit")[0]
        env.defaultsizelimit = env.config.getcoordlist(
            "album generation", "default_image_size_limit")[0]

        imgsizesval = env.config.getcoordlist(
            "album generation", "other_image_size_limits")
        imgsizesset = Set(imgsizesval) # Get rid of duplicates.
        defaultlimit = env.config.getcoordlist(
            "album generation", "default_image_size_limit")[0]
        imgsizesset.add(defaultlimit)
        imgsizes = list(imgsizesset)
        imgsizes.sort(lambda x, y: cmp(x[0] * x[1], y[0] * y[1]))
        env.imagesizelimits = imgsizes

        commandTable[args[0]](env, args[1:])
        if env.noAct:
            env.shelf.rollback()
            printOutput("no-act: All changes to the database have been revoked!\n")
        else:
            env.shelf.commit()
        sys.exit(0)
    except ArgumentError:
        printErrorAndExit(
            "Bad arguments to command. See \"kofoto --help\" for help.\n")
    except UndeletableAlbumError, x:
        printError("Undeletable album: \"%s\".\n" % env.to_l(x.args[0]))
    except BadAlbumTagError, x:
        printError("Bad album tag: \"%s\".\n" % env.to_l(x.args[0]))
    except AlbumExistsError, x:
        printError("Album already exists: \"%s\".\n" % env.to_l(x.args[0]))
    except ImageDoesNotExistError, x:
        printError("Image does not exist: \"%s\".\n" % env.to_l(x.args[0]))
    except AlbumDoesNotExistError, x:
        printError("Album does not exist: \"%s\".\n" % env.to_l(x.args[0]))
    except ObjectDoesNotExistError, x:
        printError("Object does not exist: \"%s\".\n" % env.to_l(x.args[0]))
    except UnknownAlbumTypeError, x:
        printError("Unknown album type: \"%s\".\n" % env.to_l(x.args[0]))
    except UnsettableChildrenError, x:
        printError("Cannot modify children of \"%s\" (children are created virtually).\n" % env.to_l(x.args[0]))
    except CategoryExistsError, x:
        printError("Category already exists: \"%s\".\n" % env.to_l(x.args[0]))
    except CategoryDoesNotExistError, x:
        printError("Category does not exist: \"%s\".\n" % env.to_l(x.args[0]))
    except BadCategoryTagError, x:
        printError("Bad category tag: %s.\n" % env.to_l(x.args[0]))
    except CategoryPresentError, x:
        printError("Object %s is already associated with category %s.\n" % (
            env.to_l(x.args[0]), env.to_l(x.args[1])))
    except CategoriesAlreadyConnectedError, x:
        printError("Categories %s and %s are already connected.\n" % (
            env.to_l(x.args[0]), env.to_l(x.args[1])))
    except CategoryLoopError, x:
        printError("Connecting %s to %s would make a loop in the categories.\n" % (
            env.to_l(x.args[0]), env.to_l(x.args[1])))
    except ParseError, x:
        printError("While parsing search expression: %s.\n" % env.to_l(x.args[0]))
    except UnterminatedStringError, x:
        printError("While scanning search expression: unterminated string starting at character %d.\n" % (
            env.to_l(x.args[0])))
    except BadTokenError, x:
        printError("While scanning search expression: bad token starting at character %d.\n" % (
            env.to_l(x.args[0])))
    except KeyboardInterrupt:
        printOutput("Interrupted.\n")
    except IOError, e:
        if e.filename:
            errstr = "%s: \"%s\"" % (e.strerror, e.filename)
        else:
            errstr = e.strerror
        printError("%s.\n" % errstr)
    env.shelf.rollback()
    sys.exit(1)


######################################################################
### Main.

if __name__ == "__main__":
    main(sys.argv)
